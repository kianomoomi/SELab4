به نام خدا

# آزمایش چهارم آزمایشگاه مهندسی نرم‌افزار (Object Oriented Design Patterns)
## مقدمات آزمایش
در این آزمایش قصد داریم تا با دو عدد از الگوهای طراحی GoF یعنی الگو‌های State و Strategy آشنا شویم. برای این منظور یک سیستم اعلام وضعیت بسته‌های پستی ساده را طراحی می‌کنیم که توضیحات آن در دستور آزمایش وجود دارد.
## شرح آزمایش
در ابتدا طبق خواسته سوال به صورت TDD عمل می کنیم و ابتدا تست ها را می نویسیم. بدین منظور ۲ تست به صورت زیر می‌نویسیم و همانطور که انتظار داریم تست‌ها پاس نخواهند شد.
![image](https://github.com/kianomoomi/SELab4/assets/59165380/d5e479e6-09c3-4f19-8c21-79bacecafa83)
حال باید کلاس‌های مربوطه را ایجاد کنیم. ابتدا می‌خواهیم الگوی Strategy را محقق کنیم. بنابراین یک اینترفیس ShippingStrategy می‌سازیم و کلاس‌های StandardShipping و ExpressShiping آن را implement می‌کنند.
![image](https://github.com/kianomoomi/SELab4/assets/59165380/b3c418a7-ce56-486d-891f-959baf3b8ffe)
![image](https://github.com/kianomoomi/SELab4/assets/59165380/3d593309-66b2-4205-b1bc-39ac29b8d04e)
![image](https://github.com/kianomoomi/SELab4/assets/59165380/868dcf8d-9ef7-44fe-9853-14034dbb263f)

حال می‌خواهیم الگوی State را برقرار کنیم. در اینجا وضعیت بسته همان State می‌باشد. الگوی State کمک می‌کند تا تا یک شی وقتی که استیت داخلیش تغییر می‌کند، رفتار خود را تغییر دهد. بنابراین برای محقق‌سازی این الگو یک اینترفیس State می‌سازیم و کلاس‌های InTransitState و DeliveredState آن‌ را implement می‌کنند.
![image](https://github.com/kianomoomi/SELab4/assets/59165380/16b6f651-10d0-4d8b-ae27-b8f6e4576bf2)
![image](https://github.com/kianomoomi/SELab4/assets/59165380/19d2be80-ddf3-40d2-be55-4b2cb3d9cb2d)
![image](https://github.com/kianomoomi/SELab4/assets/59165380/caa33e4e-2e36-4d16-a347-168a902a2573)
حال به پیاده‌سازی کلاس Product که همان بسته ما می‌باشد می‌پردازیم و از این الگو‌ها استفاده می‌کنیم.
![image](https://github.com/kianomoomi/SELab4/assets/59165380/5b237e36-84ef-4549-b92f-4f535205c6e3)
و در نهایت کلاس Main را با توجه به این الگو‌ها پیاده‌سازی می‌کنیم که می‌توانید کد آن را در مخزن مشاهده کنید.
در نهایت پس از پیاده‌سازی کامل برنامه مشاهده خواهیم کرد که تست‌هایی که در ابتدا پاس نشده بودند، اکنون پاس می‌شوند!
![image](https://github.com/kianomoomi/SELab4/assets/59165380/11821c2f-eb8b-4155-b55c-f93644abd565)

## پرسش‌ها

1.در کتاب GoF سه دسته الگوی طراحی معرفی شده است. آن‌ها را نام ببرید و در مورد هر دسته در حد دو خط توضیح دهید.

- **Creational Patterns**:

این الگوها روش‌های مختلفی را برای ایجاد شیء (Object) ارائه می‌دهند که باعث افزایش انعطاف‌پذیری و قابلیت استفاده مجدد از کد می‌شود. در واقع نحوه ایجاد و مقداردهی اولیه شیءها را توصیف می‌کنند
- **Structural Patterns**:

این الگوها نحوه سازماندهی و ساختاردهی کلاس‌ها و شیءها در یک ساختار بزرگ را توضیح می‌دهند به طوری که ساختار نهایی انعطاف‌پذیر و کارآمد باقی بماند.
- **Behavioral Patterns**:

این الگوها روش‌های مختلفی را برای توزیع مسئولیت‌ها بین شیءها ارائه می‌دهند. این الگوها به ما کمک می‌کنند تا الگوریتم‌ها و رفتارهای پیچیده را به شکل مناسبی مدیریت کنیم. در واقع نحوه ارتباط یا تعامل بین شیءها یا کلاس‌ها را توصیف می‌کنند.

2.الگوهای استفاده شده در این آزمایش جزو کدام دسته هستند؟

الگو‌های مطرح شده در این آزمایش جزو دسته‌ی `Behavioral Patterns` می‌باشند.

3. با توجه به این که در هر اجرا محصرا یک بسته داریم و هیچ بسته‌ی دیگری بجز آن نداریم، کدام الگوی طراحی را برای ایحاد آن مناسب می‌دانید؟ ضمن بیان علت انتخاب خود، نحوه تحقق الگو را به طور کامل توضیح دهید.

الگوی طراحی مد نظر الگوی Singleton می‌باشد که Creational است. دیاگرام آن را در زیر می‌بینید. 
![image](https://github.com/kianomoomi/SELab4/assets/59336942/efb5c31c-811f-40ad-b26d-293557173c8f)

برای اینکه در هر اجرا فقط یک بسته داشته باشیم، الگوی طراحی Singleton مناسب است. این الگو اطمینان حاصل می‌کند که یک کلاس فقط یک نمونه داشته باشد و یک نقطه دسترسی عمومی برای آن فراهم می‌کند که از هرجا که به آن دسترسی داریم، بتوانیم از آن استفاده کنیم. در زیر تکه کد پیاده‌سازی آن را می‌بینید:
```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
در این کد، ما یک کلاس با نام Singleton ایجاد کرده‌ایم. سازنده این کلاس خصوصی است، بنابراین هیچ کلاس دیگری نمی‌تواند از آن استفاده کند. ما یک متد استاتیک با نام getInstance داریم که یک نمونه از کلاس Singleton را برمی‌گرداند. اگر نمونه قبلا ایجاد نشده باشد، این متد یک نمونه جدید ایجاد می‌کند و برمی‌گرداند. اگر نمونه قبلا ایجاد شده باشد، این متد نمونه موجود را برمی‌گرداند. به این ترتیب، ما همیشه فقط یک نمونه از کلاس Singleton داریم.
همچنین چون state داریم نیز الگوی طراحی state و strategy خوب است که با آن آمیخته شود.

4. تحقق و یا عدم تحقق هر کدام از اصول SOLID را در خصوص الگوی طراحی Singleton بیان کنید (هرکدام حداکثر در سه خط).
الگوی طراحی Singleton در مورد اصول SOLID به شرح زیر است:

- **Single Responsibility Principle (SRP)**:

الگوی Singleton این اصل را رعایت می‌کند. یک کلاس Singleton فقط یک مسئولیت دارد و آن اطمینان از وجود یک نمونه از یک کلاس است. البته ممکن است کلاس تبدیل به god class شود که در این صورت بد است ولی به خودی خود مشکلی ندارد. البته بعضی می‌گویند چون cycle خود را کنترل می‌کند مسئولیت اضافه دارد و نقض SRP است.
-  **Open/Closed Principle (OCP)**:

این الگو این اصل را رعایت نمی‌کند. یک کلاس Singleton برای تغییرات بسته است و نمی‌توان آن را گسترش داد. معمولا از وراثت جلوگیری می‌کند. البته اگر به نحو درست پیاده‌سازی شود می‌تواند جلوی این را بگیرد. ولی معمولا باعث می‌شود که تغییرات به سختی صورت گیرند.
- **Liskov Substitution Principle (LSP)**:

این اصل در مورد الگوی Singleton کاربردی نیست. این اصل بیان می‌کند که یک نوع باید قابل جایگزینی با زیرنوع‌های خود باشد. اما در Singleton، ما فقط یک نمونه داریم و زیرنوع‌ها معنایی ندارند. پس آسیبی به این اصل وارد نیست. البته بعضی می‌گویند که الگوی Singleton می تواند اصل LSP را نقض کند زیرا با کنترل خلق و عمر خود، ارث بری را محدود میکند.

- **Interface Segregation Principle (ISP)**:

این اصل در مورد الگوی Singleton کاربردی نیست. این اصل بیان می‌کند که کلاس‌ها نباید وابسته به رابط‌هایی باشند که از آن‌ها استفاده نمی‌کنند. اما در Singleton، ما با رابط‌ها کار نمی‌کنیم. پس آسیبی به این اصل وارد نیست. البته بعضی معتقند البته که الگوی Singleton می تواند اصل ISP را نقض کند زیرا معمولاً یک نقطه دسترسی جهانی به یک نمونه خاص فراهم می کند، که به این معنی است که هر بخشی از کد می تواند به آن دسترسی داشته باشد، چه آن نیاز داشته باشد یا نه.
- **Dependency Inversion Principle (DIP)**:

این الگو این اصل را رعایت می‌کند. یک کلاس Singleton وابستگی‌های خود را کنترل می‌کند و از وابستگی به کلاس‌های خاص خودداری می‌کند. البته بعضی می‌گویند از آن جا که بر اساس concrete implementation است و نه abstractions پس این اصل را نقض می‌کند.  

